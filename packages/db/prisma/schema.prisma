// Prisma Schema for AI File Cleanup System
// PostgreSQL with pgvector extension

generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["postgresqlExtensions"]
}

generator py {
  provider             = "prisma-client-py"
  recursive_type_depth = 5
  interface            = "asyncio"
}

datasource db {
  provider   = "postgresql"
  url        = env("DATABASE_URL")
  extensions = [vector]
}

/// User accounts (test/seeded in MVP)
model User {
  id           String   @id @default(uuid()) @db.Uuid
  email        String   @unique
  name         String?
  passwordHash String   @map("password_hash")
  createdAt    DateTime @default(now()) @map("created_at") @db.Timestamptz(6)
  updatedAt    DateTime @updatedAt @map("updated_at") @db.Timestamptz(6)

  // Relations
  licenseKeys LicenseKey[]
  uploads     Upload[]

  @@map("users")
}

/// License keys for desktop app
model LicenseKey {
  key       String   @id @default(uuid()) @db.Uuid
  userId    String   @map("user_id") @db.Uuid
  createdAt DateTime @default(now()) @map("created_at") @db.Timestamptz(6)
  revoked   Boolean  @default(false)

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([revoked, createdAt])
  @@map("license_keys")
}

/// Upload sessions (web app)
model Upload {
  id         String   @id @default(uuid()) @db.Uuid
  userId     String?  @map("user_id") @db.Uuid
  totalFiles Int      @default(0) @map("total_files")
  createdAt  DateTime @default(now()) @map("created_at") @db.Timestamptz(6)

  // Relations
  user         User?         @relation(fields: [userId], references: [id], onDelete: SetNull)
  files        File[]
  dedupeGroups DedupeGroup[]

  @@index([userId, createdAt])
  @@map("uploads")
}

/// File metadata
model File {
  id          String   @id @default(uuid()) @db.Uuid
  uploadId    String?  @map("upload_id") @db.Uuid
  fileName    String   @map("file_name")
  mimeType    String   @map("mime_type")
  sizeBytes   BigInt   @map("size_bytes")
  sha256      String
  phash       String?
  textExcerpt String?  @map("text_excerpt")
  createdAt   DateTime @default(now()) @map("created_at") @db.Timestamptz(6)

  // Relations
  upload         Upload?        @relation(fields: [uploadId], references: [id], onDelete: Cascade)
  embedding      FileEmbedding?
  keptInGroup    DedupeGroup[]  @relation("KeptFile")

  @@index([uploadId])
  @@index([sha256])
  @@index([phash])
  @@map("files")
}

/// Vector embeddings (pgvector)
model FileEmbedding {
  fileId       String                       @id @map("file_id") @db.Uuid
  kind         FileEmbeddingKind
  embedding    Unsupported("vector(768)")?  // Text embedding (DistilBERT)
  embeddingImg Unsupported("vector(512)")?  @map("embedding_img") // Image embedding (CLIP)

  // Relations
  file File @relation(fields: [fileId], references: [id], onDelete: Cascade)

  @@map("file_embeddings")
}

/// Deduplication groups
model DedupeGroup {
  id          String  @id @default(uuid()) @db.Uuid
  uploadId    String  @map("upload_id") @db.Uuid
  groupIndex  Int     @map("group_index")
  keptFileId  String? @map("kept_file_id") @db.Uuid

  // Relations
  upload   Upload @relation(fields: [uploadId], references: [id], onDelete: Cascade)
  keptFile File?  @relation("KeptFile", fields: [keptFileId], references: [id], onDelete: SetNull)

  @@unique([uploadId, groupIndex])
  @@index([uploadId])
  @@map("dedupe_groups")
}

/// File embedding kind enum
enum FileEmbeddingKind {
  image
  text

  @@map("file_embedding_kind")
}

